#include "Anonymization.h"
#include "log/log.h"
#include "YOLOv8_face.h"
#include <iostream>
#include <fstream>
#include <cstring>
#include <cstdio>
#include <cstdlib>


FILE *log_file = NULL;
YOLOv8_face m_YOLOv8_face_model;

const char* Anonymization_API get_version()
{
    return "v1.0.0";
}

int Anonymization_API set_log_filelevel(IN const char* logPath, IN LOG_LEVEL logLevel)
{
    FILE *log_file = fopen(logPath, "a");
    if (!log_file) {
        perror("无法打开日志文件");
        return LOAD_LOG_ERROR;
    }
    log_set_fp(log_file);
    log_set_level(logLevel);
    
    log_info("日志文件启动");
    return ANO_OK;
}

int Anonymization_API init(IN const std::string modelPathDir, IN RecognizeType recognizeType, OUT AnonymizationHandle *handle)
{
    std::cout << "enter init()" << std::endl;
    
    // 根据识别类型，选择不同的模型
    std::string typeStr;
    switch (recognizeType)
    {
    case RECOGNIZE_FACE:
        typeStr = "bestface.onnx";
        break;
    case RECOGNIZE_LICENSE_PLATE:
        typeStr = "bestplate.onnx";
        break;
    case RECOGNIZE_ALL:
        typeStr = "bestall.onnx";
        break;
    default:
        return INVALID_PARAMETER;
    }

    std::string modelPath = modelPathDir + "/" + typeStr;

    // 如果文件格式正确
    std::ifstream file(modelPath);
    if (file.is_open()) 
    {
        file.close();
        m_YOLOv8_face_model.set_YOLOv8_face_Info(modelPath, 0.45, 0.5);
        return ANO_OK;
    } 
    else 
    {
        return MODEL_NOT_EXIST;
    }
}

int Anonymization_API uninit(IN AnonymizationHandle handle)
{
    log_info("脱敏程序结束");

    // 在关闭文件前，先将日志输出切换到其他流（如 stderr）
    log_set_fp(stderr);  // 避免 log_log() 继续使用已关闭的文件
    
    if (log_file) {
        fclose(log_file);
        log_file = NULL;  // 防止重复关闭
    }
    

    return ANO_OK;
}


int Anonymization_API image_anonymization(IN AnonymizationHandle handle, const char* inputFile, const char* outputFile, em_anonymization_blur_type anonymization_blur_type)
{
    // 使用OpenCV的imread函数读取图片
    cv::Mat frame = cv::imread(inputFile, cv::IMREAD_COLOR);
 
    // 检查图片是否成功加载
    if(frame.empty())
    {
        std::cout << "图片加载失败" << std::endl;
        return Load_Image_Error;
    }
    else
    {
        m_YOLOv8_face_model.detect(frame, anonymization_blur_type);
        bool result = cv::imwrite(outputFile, frame);
        if (result)
        {
            std::cout << "图片存储成功!" << std::endl;
            return ANO_OK;
        } 
        else 
        {
            std::cout << "图片存储失败!" << std::endl;
            return Save_Image_Error;
        }
    }
}

int Anonymization_API mem_anonymization(IN AnonymizationHandle handle, 
                                        IN_OUT ImageFrame *image,
                                        IN BlurType blurType)
{
    if (image == NULL) {
        return INVALID_PARAMETER;
    }

    cv::Mat frame;
    
    // 根据不同的图像格式，将数据转换为OpenCV的Mat格式
    switch (image->format) {
        case IMG_FORMAT_BGR:
            // OpenCV默认使用BGR格式，直接创建Mat
            frame = cv::Mat(image->height, image->width, CV_8UC3, 
                           image->data[0], image->strides[0]);
            break;
            
        case IMG_FORMAT_RGB:
            // 将RGB数据转换为BGR
            frame = cv::Mat(image->height, image->width, CV_8UC3, 
                           image->data[0], image->strides[0]);
            cv::cvtColor(frame, frame, cv::COLOR_RGB2BGR);
            break;
            
        case IMG_FORMAT_ARGB:
            // 将ARGB数据转换为BGR，忽略Alpha通道
            frame = cv::Mat(image->height, image->width, CV_8UC4, 
                           image->data[0], image->strides[0]);
            cv::cvtColor(frame, frame, cv::COLOR_ARGB2BGR);
            break;
            
        case IMG_FORMAT_GRAY:
            // 灰度图像
            frame = cv::Mat(image->height, image->width, CV_8UC1, 
                           image->data[0], image->strides[0]);
            // 如果需要彩色输出，将灰度图转换为BGR
            cv::cvtColor(frame, frame, cv::COLOR_GRAY2BGR);
            break;
            
        case IMG_FORMAT_YUV420P: {
            // YUV420P (planar) 格式：Y平面 followed by U和V平面
            cv::Mat yuvImage(image->height * 3 / 2, image->width, CV_8UC1);
            
            // 复制Y平面
            memcpy(yuvImage.data, image->data[0], 
                  image->height * image->strides[0]);
            
            // 复制U平面
            memcpy(yuvImage.data + image->height * image->strides[0], 
                  image->data[1], 
                  (image->height / 2) * image->strides[1]);
            
            // 复制V平面
            memcpy(yuvImage.data + image->height * image->strides[0] + 
                  (image->height / 2) * image->strides[1], 
                  image->data[2], 
                  (image->height / 2) * image->strides[2]);
            
            // 转换为BGR
            cv::cvtColor(yuvImage, frame, cv::COLOR_YUV2BGR_I420);
            break;
        }
            
        case IMG_FORMAT_YUV420SP: {
            // YUV420SP (semi-planar) 格式：Y平面 followed by UV交叉平面
            cv::Mat yuvImage(image->height * 3 / 2, image->width, CV_8UC1);
            
            // 复制Y平面
            memcpy(yuvImage.data, image->data[0], 
                  image->height * image->strides[0]);
            
            // 复制UV平面
            memcpy(yuvImage.data + image->height * image->strides[0], 
                  image->data[1], 
                  (image->height / 2) * image->strides[1] * 2);
            
            // NV12 (UV交叉) 转换为BGR
            cv::cvtColor(yuvImage, frame, cv::COLOR_YUV2BGR_NV12);
            break;
        }
            
        default:
            std::cout << "不支持的图像格式: " << image->format << std::endl;
            return UNSUPPORTED_FORMAT;
    }

    // 检查图像是否成功创建
    if (frame.empty()) {
        std::cout << "无法创建图像对象" << std::endl;
        return INVALID_PARAMETER;
    }

    // 进行人脸和车牌检测与模糊处理
    m_YOLOv8_face_model.detect(frame, blurType);

    // 将处理后的图像数据转回原始格式
    switch (image->format) {
        case IMG_FORMAT_BGR:
            // 直接复制回原始数据
            memcpy(image->data[0], frame.data, 
                  frame.rows * frame.step);
            break;
            
        case IMG_FORMAT_RGB:
            // 转换回RGB格式
            cv::cvtColor(frame, frame, cv::COLOR_BGR2RGB);
            memcpy(image->data[0], frame.data, 
                  frame.rows * frame.step);
            break;
            
        case IMG_FORMAT_ARGB:
            // 转换回ARGB格式，假设Alpha通道全为255
            cv::Mat argbImage(frame.rows, frame.cols, CV_8UC4);
            cv::cvtColor(frame, argbImage, cv::COLOR_BGR2BGRA);
            memcpy(image->data[0], argbImage.data, 
                  argbImage.rows * argbImage.step);
            break;
            
        case IMG_FORMAT_GRAY:
            // 转换回灰度图
            cv::Mat grayImage;
            cv::cvtColor(frame, grayImage, cv::COLOR_BGR2GRAY);
            memcpy(image->data[0], grayImage.data, 
                  grayImage.rows * grayImage.step);
            break;
            
        case IMG_FORMAT_YUV420P: {
            // 转换回YUV420P格式
            cv::Mat yuvImage;
            cv::cvtColor(frame, yuvImage, cv::COLOR_BGR2YUV_I420);
            
            // 分离Y、U、V平面
            int y_size = image->width * image->height;
            int uv_size = y_size / 4;
            
            memcpy(image->data[0], yuvImage.data, y_size);
            memcpy(image->data[1], yuvImage.data + y_size, uv_size);
            memcpy(image->data[2], yuvImage.data + y_size + uv_size, uv_size);
            break;
        }
            
        case IMG_FORMAT_YUV420SP: {
            // 转换回YUV420SP (NV12) 格式
            cv::Mat yuvImage;
            cv::cvtColor(frame, yuvImage, cv::COLOR_BGR2YUV_YV12);
            
            // 分离Y平面和UV交叉平面
            int y_size = image->width * image->height;
            int uv_size = y_size / 2;
            
            // 复制Y平面
            memcpy(image->data[0], yuvImage.data, y_size);
            
            // 转换VU (YV12) 为UV (NV12)
            uint8_t* vu_plane = yuvImage.data + y_size;
            uint8_t* uv_plane = new uint8_t[uv_size];
            
            for (int i = 0; i < uv_size / 2; i++) {
                uv_plane[i*2] = vu_plane[i + uv_size/4];  // U
                uv_plane[i*2+1] = vu_plane[i];            // V
            }
            
            memcpy(image->data[1], uv_plane, uv_size);
            delete[] uv_plane;
            break;
        }
            
        default:
            std::cout << "不支持的图像格式: " << image->format << std::endl;
            return UNSUPPORTED_FORMAT;
    }

    return ANO_OK;
}

int Anonymization_API video_anonymization(IN AnonymizationHandle handle, 
                                          IN const char* inputFile, 
                                          OUT const char* outputFile,
                                          IN BlurType blurType)
{
    // 打开输入视频文件
    cv::VideoCapture videoCapture(inputFile);
    if (!videoCapture.isOpened())
    {
        std::cout << "视频加载失败: " << inputFile << std::endl;
        return LOAD_VIDEO_ERROR;
    }

    // 获取视频的基本信息
    int frameWidth = static_cast<int>(videoCapture.get(cv::CAP_PROP_FRAME_WIDTH));
    int frameHeight = static_cast<int>(videoCapture.get(cv::CAP_PROP_FRAME_HEIGHT));
    double fps = videoCapture.get(cv::CAP_PROP_FPS);
    int fourcc = static_cast<int>(videoCapture.get(cv::CAP_PROP_FOURCC));

    // 创建输出视频写入器
    cv::VideoWriter videoWriter;
    videoWriter.open(outputFile, fourcc, fps, cv::Size(frameWidth, frameHeight));
    if (!videoWriter.isOpened())
    {
        std::cout << "无法创建输出视频文件: " << outputFile << std::endl;
        videoCapture.release();
        return SAVE_VIDEO_ERROR;
    }

    // 处理视频帧
    cv::Mat frame;
    int frameCount = 0;
    int processedFrames = 0;

    while (videoCapture.read(frame))
    {
        frameCount++;
        
        // 对当前帧进行脱敏处理
        m_YOLOv8_face_model.detect(frame, blurType);
        
        // 写入处理后的帧
        videoWriter.write(frame);
        processedFrames++;
        
        // 每处理100帧显示一次进度
        if (frameCount % 100 == 0)
        {
            std::cout << "已处理 " << frameCount << " 帧" << std::endl;
        }
    }

    // 释放资源
    videoCapture.release();
    videoWriter.release();

    // 检查是否至少处理了一帧
    if (processedFrames > 0)
    {
        std::cout << "视频处理完成，共处理 " << processedFrames << " 帧" << std::endl;
        return ANO_OK;
    }
    else
    {
        std::cout << "未处理任何帧" << std::endl;
        return LOAD_VIDEO_ERROR;
    }
}